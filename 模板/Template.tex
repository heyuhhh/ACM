% !TEX encoding = UTF-8 Unicode
\documentclass[a4paper,11pt,twoside,fontset = fandol,UTF8]{ctexbook} % 页面A4纸大小，11 磅大小的字体，式样为双面，字体集为Fandol，编码为UTF8，文档类型为cTex的book（支持中文）
\usepackage[a4paper,scale=0.8,hcentering,bindingoffset=8mm]{geometry} % A4纸大小，缩放80%，设置奇数页右边留空多一点
\usepackage{hyperref}      % 超链接
\usepackage{listings}      % 代码块
\usepackage{courier}       % 字体
\usepackage{fontspec}      % 字体
\usepackage{fancyhdr}      % 页眉页脚相关宏包
\usepackage{lastpage}      % 引用最后一页
\usepackage{amsmath,amsthm,amsfonts,amssymb,bm} %数学
\usepackage{graphicx}      % 图片
\usepackage{subcaption}    % 图片描述
\usepackage{longtable,booktabs} % 表格

\setmonofont{Consolas}    %设置字体为Consolas
\lstset{                  %设置代码块
	basicstyle=\footnotesize\ttfamily,% 基本风格
	numbers=left,    % 行号
	numbersep=10pt,  % 行号间隔 
	tabsize=2,       % 缩进
	extendedchars=true, % 扩展符号？
	breaklines=true, % 自动换行
	language=C++,
	frame=leftline,  % 框架左边竖线
	xleftmargin=19pt,% 竖线左边间距
	showspaces=false,% 空格字符加下划线
	showstringspaces=false,% 字符串中的空格加下划线
	showtabs=false,  % 字符串中的tab加下划线
}
\pagestyle{fancy}         % 页眉页脚风格
\fancyhf{}                % 清空当前设置
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}%页脚中间显示 当前页 / 总页数，把\label{LastPage}放在最后
\fancyhead[LO,RE]{\thepage}% 页眉奇数页左边，偶数页右边显示当前页
\begin{document} 
	\begin{titlepage}       % 封面
		\centering
		\vspace*{\baselineskip}
		\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
		\rule{\textwidth}{0.4pt}\\[\baselineskip]
		{\LARGE The template\\[\baselineskip]\small for ACM ICPC}
		\\[0.2\baselineskip]
		\rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}
		\rule{\textwidth}{1.6pt}\\[\baselineskip]
		\scshape
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=0.3\textwidth]{icpc}    % 当前tex文件同一目录下名为icpc的任意格式图片
		\end{figure}
		
		\vspace*{3\baselineskip}
		Edited by \\[\baselineskip] {heyuhhh\par}
		{Team \Large 万物静默如谜 \normalsize{at Sicau}\par }
		\vfill
		{\scshape 2019.10} \\{\large NANCHONG}\par
	\end{titlepage}
	\newpage            % 封面背后空白页
	\tableofcontents     % 目录
	\chapter{图论}    % 第一章
	\setcounter{page}{1} % 这里页数从1开始计算
	\section{最短路}   % 第一节
	% 代码块
	\subsection{堆优化Dijkstra}
	\begin{lstlisting}
void Dijkstra(int s){
    priority_queue <node> q;
	memset(d, INF, sizeof(d));
    memset(vis, 0, sizeof(vis)); d[s]=0;
    q.push(node{0, s});
    while(!q.empty()){
        node cur = q.top(); q.pop();
        int u = cur.u;
        if(vis[u]) continue ;
        vis[cur.u] = 1;
        for(int i = head[u]; i != -1; i = e[i].next){
            int v = e[i].v;
            if(d[v] > d[u] + e[i].w){
                d[v] = d[u] + e[i].w;
                q.push(node{d[v], v});
            }
        }
    }
}
	\end{lstlisting}
	% ...其它内容
	\subsection{spfa}
	\begin{lstlisting}
//c:判断有无负环
int spfa(int s){
    queue <int> q;
    memset(d, INF, sizeof(d));
    memset(vis, 0, sizeof(vis));
    memset(c, 0, sizeof(c));
    q.push(s);
    vis[s] = 1; d[s] = 0; c[s] = 1;
    while(!q.empty()){
        int u = q.front(); q.pop(); vis[u]=0;
        if(c[u] > n){
            return -1;
        }
        for(int i = head[u];i != -1;i = e[i].next){
            int v = e[i].v;
            if(d[v] > d[u] + e[i].w){
                d[v] = d[u] + e[i].w;
                fa[v] = u;
                if(!vis[v]){
                    vis[v] = 1;
                    q.push(v);
                    c[v]++;
                }
            }
        }
    }
    return d[n];
}
	\end{lstlisting}
	\section{网络流}
	\subsection{Dinic}
复杂度玄学
	\begin{lstlisting}
#define INF 0x3f3f3f3f
template <class T> //模板，可处理double类型
struct Dinic{
    struct Edge{
        int v, next;
        T flow;
        Edge(){}
        Edge(int v, int next, T flow) : v(v), next(next), flow(flow) {}
    }e[N << 1];
    int head[N], tot;
    int dep[N];
    void init() {
        memset(head, -1, sizeof(head)); tot = 0;
    }
    void adde(int u, int v, T w, T rw = 0) {
        e[tot] = Edge(v, head[u], w);
        head[u] = tot++;
        e[tot] = Edge(u, head[v], rw);
        head[v] = tot++;
    }
    bool BFS(int _S, int _T) {
        memset(dep, 0, sizeof(dep));
        queue <int> q; q.push(_S); dep[_S] = 1;
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for(int i = head[u]; ~i; i = e[i].next) {
                int v = e[i].v;
                if(!dep[v] && e[i].flow > 0) {
                    dep[v] = dep[u] + 1;
                    q.push(v);
                }
            }
        }
        return dep[_T] != 0;
    }
    T dfs(int _S, int _T, T a) {
        T flow = 0, f;
        if(_S == _T || a == 0) return a;
        for(int i = head[_S]; ~i; i = e[i].next) {
            int v = e[i].v;
            if(dep[v] != dep[_S] + 1) continue;
            f = dfs(v, _T, min(a, e[i].flow));
            if(f) {
                e[i].flow -= f;
                e[i ^ 1].flow += f;
                flow += f;
                a -= f;
                if(a == 0) break;
            }
        }
        if(!flow) dep[_S] = -1;
        return flow;
    }
    T dinic(int _S, int _T) {
        T max_flow = 0;
        while(BFS(_S, _T)) max_flow += dfs(_S, _T, INF);
        return max_flow;
    }
};
	\end{lstlisting}
	\subsection{费用流}
势优化过后的dijkstra，可以处理负边权。
	\begin{lstlisting}
#define INF 0x3f3f3f3f
struct edge {
	int to, capacity, cost, rev;
	edge() {}
	edge(int to, int _capacity, int _cost, int _rev) :to(to), capacity(_capacity), cost(_cost), rev(_rev) {}
};
struct Min_Cost_Max_Flow {
	int V, H[N << 1], dis[N << 1], PreV[N << 1], PreE[N << 1];
	vector<edge> G[N << 1];
	void Init(int n) {
		V = n;
		for (int i = 0; i <= V; ++i)G[i].clear();
	}
	void Add_Edge(int from, int to, int cap, int cost) {
		G[from].push_back(edge(to, cap, cost, G[to].size()));
		G[to].push_back(edge(from, 0, -cost, G[from].size() - 1));
	}
//flow是自己传进去的变量，就是最后的最大流，返回的是最小费用，f=INF
	int Min_cost_max_flow(int s, int t, int f, int& flow) {
		int res = 0; fill(H, H + 1 + V, 0);
		while (f) {
			priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > q;
			fill(dis, dis + 1 + V, INF);
			dis[s] = 0; q.push(pair<int, int>(0, s));
			while (!q.empty()) {
				pair<int, int> now = q.top(); q.pop();
				int v = now.second;
				if (dis[v] < now.first)continue;
				for (int i = 0; i < G[v].size(); ++i) {
					edge& e = G[v][i];
					if (e.capacity > 0 && dis[e.to] > dis[v] + e.cost + H[v] - H[e.to]) {
						dis[e.to] = dis[v] + e.cost + H[v] - H[e.to];
						PreV[e.to] = v;
						PreE[e.to] = i;
						q.push(pair<int, int>(dis[e.to], e.to));
					}
				}
			}
			if (dis[t] == INF)break;
			for (int i = 0; i <= V; ++i)H[i] += dis[i];
			int d = f;
			for (int v = t; v != s; v = PreV[v])d = min(d, G[PreV[v]][PreE[v]].capacity);
			f -= d; flow += d; res += d*H[t];
			for (int v = t; v != s; v = PreV[v]) {
				edge& e = G[PreV[v]][PreE[v]];
				e.capacity -= d;
				G[v][e.rev].capacity += d;
			}
		}
		return res;
	}
	int Max_cost_max_flow(int s, int t, int f, int& flow) {
		int res = 0;
		fill(H, H + 1 + V, 0);
		while (f) {
			priority_queue <pair<int, int>> q;
			fill(dis, dis + 1 + V, -INF);
			dis[s] = 0;
			q.push(pair<int, int>(0, s));
			while (!q.empty()) {
				pair<int, int> now = q.top(); q.pop();
				int v = now.second;
				if (dis[v] > now.first)continue;
				for (int i = 0; i < G[v].size(); ++i) {
					edge& e = G[v][i];
					if (e.capacity > 0 && dis[e.to] < dis[v] + e.cost + H[v] - H[e.to]) {
						dis[e.to] = dis[v] + e.cost + H[v] - H[e.to];
						PreV[e.to] = v;
						PreE[e.to] = i;
						q.push(pair<int, int>(dis[e.to], e.to));
					}
				}
			}
			if (dis[t] == -INF)break;
			for (int i = 0; i <= V; ++i)H[i] += dis[i];
			int d = f;
			for (int v = t; v != s; v = PreV[v])d = min(d, G[PreV[v]][PreE[v]].capacity);
			f -= d; flow += d;
			res += d*H[t];
			for (int v = t; v != s; v = PreV[v]) {
				edge& e = G[PreV[v]][PreE[v]];
				e.capacity -= d;
				G[v][e.rev].capacity += d;
			}
		}
		return res;
	}
}sol;
	\end{lstlisting}
	\section{连通性}
	\subsection{有向图强连通分量}
	Tarjan算法，复杂度$O(n)$，能够求出有向图的极大强连通分量。
	\begin{lstlisting}
stack <int> s;
int T, num;
int scc[N], dfn[N], low[N], vis[N];
void Tarjan(int u){
    dfn[u] = low[u] = ++T; vis[u] = 1;
    s.push(u);
    for(int i = head[u]; i != -1;i = e[i].next){
        int v = e[i].v;
        if(!vis[v]){
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }else if(!scc[v]){
            low[u] = min(low[u], dfn[v]);
        }
    }
    if(low[u] == dfn[u]){
        num++; int now;
        do{
            now = s.top(); s.pop();
            scc[now] = num;
        }while(!s.empty() && now!=u);
    }
}
	\end{lstlisting}
	
	\subsection{2-sat}
	通过在反图上求强连通分量，优先选择序号较大者。
	\begin{lstlisting}
vector<int> G[N], rG[N], vs;
int used[N], bel[N];

void adde(int from, int to) {
    G[from].push_back(to);
    rG[to].push_back(from);
}

void dfs(int v) {
    used[v] = true;
    for(int u: G[v]) {
        if(!used[u])
            dfs(u);
    }
    vs.push_back(v);
}

void rdfs(int v, int k) {
    used[v] = true;
    bel[v] = k;
    for(int u: rG[v])
        if(!used[u])
            rdfs(u, k);
}

int scc() {
    memset(used, 0, sizeof(used));
    vs.clear();
    for(int v = 0; v < n; ++v)
        if(!used[v]) dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for(int i = (int) vs.size() - 1; i >= 0; --i)
        if(!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}
	\end{lstlisting}
	\section{生成树}
	\subsection{Kruskal算法}
	\begin{lstlisting}
struct Edge{
    int u,v,w;
    bool operator < (const Edge &A)const{
        return w<A.w;
    }
}e[N*N];
int f[N];
int find(int x){
    return f[x]==x?f[x]:f[x]=find(f[x]);
}
int Kruskal(){
    int ans=0;
    for(int i=0;i<=n+1;i++) f[i]=i;
    for(int i=1;i<=m;i++){
        int fx=find(e[i].u),fy=find(e[i].v);
        if(fx==fy) continue ;
        f[fx]=fy;
        ans+=e[i].w;
    }
    return ans ;
}
	\end{lstlisting}
	\subsection{次小生成树}
	复杂度为$O(n^2)$，貌似可以通过树上倍增优化到$O(nlogn)$。
	
	严格次小生成树则需要同时维护最大值和次大值来比较。
	\begin{lstlisting}
struct Edge{
    int u,v,w;
    bool operator < (const Edge &A)const{
        return w<A.w;
    }
}e[N*N];
int f[N],check[N];
int d[N][N],dis[N][N],mp[N][N];
int find(int x){
    return f[x]==x?f[x]:f[x]=find(f[x]);
}
int Kruskal(){
    int ans=0;
    for(int i=0;i<=n+1;i++) f[i]=i;
    for(int i=1;i<=m;i++){
        int u=e[i].u,v=e[i].v;
        int fx=find(u),fy=find(v);
        if(fx==fy) continue ;
        f[fx]=fy;
        mp[u][v]=mp[v][u]=1;
        ans+=e[i].w;
    }
    return ans ;
}
void dfs(int u,int fa){
    for(int x=1;x<=n;x++){
        if(check[x]) d[x][u]=d[u][x]=max(d[x][fa],dis[u][fa]);
    }
    check[u]=1;
    for(int v=1;v<=n;v++){
        if(mp[v][u] && v!=fa) dfs(v,u);
    }
}
	\end{lstlisting}
	\subsection{最小有向生成树}
	朱刘算法，复杂度$O(nm)$。
	\begin{lstlisting}
struct Edge{
    int u,v,w;
}e[M];
int pre[N]; //记录前驱.
int id[N],vis[N],in[N];
int dirMst(int root){
    int ans=0;
    while(1){
        memset(in,INF,sizeof(in));
        memset(id,-1,sizeof(id));
        memset(vis,-1,sizeof(vis));
        for(int i=1;i<=m;i++){
            int u=e[i].u,v=e[i].v,w=e[i].w;
            if(w<in[v] && v!=u){
                pre[v]=u;
                in[v]=w;
            }
        }           //求最小入边集
        in[root]=0;
        pre[root]=root;
        for(int i=0;i<n;i++){
            if(in[i]==INF) return -1;
            ans+=in[i];
        }
        int idx = 0; //新标号
        for(int i=0;i<n;i++){
            if(vis[i] == -1 ){
                int u = i;
                while(vis[u] == -1){
                    vis[u] = i;
                    u = pre[u];
                }
                if(vis[u]!=i || u==root) continue;     //判断是否形成环
                for(int v=pre[u];v!=u;v=pre[v] )
                    id[v]=idx;
                id[u] = idx++;
            }
        }
        if(idx==0) break;
        for(int i=0;i<n;i++){
            if(id[i]==-1) id[i]=idx++;
        }
        for(int i=1;i<=m;i++){
            e[i].w-=in[e[i].v];
            e[i].u=id[e[i].u];
            e[i].v=id[e[i].v];
        }
        n = idx;
        root = id[root];//给根新的标号
    }
    return ans;
} 
	\end{lstlisting}
	\subsection{最小生成树计数}
	b为基尔霍夫矩阵，即度数矩阵-邻接矩阵，注意要考虑重边，重复的边只算一次。
	\begin{lstlisting}
ll Det(int n){
    int i,j,k;
    ll ret = 1;
    for(i=2;i<=n;i++){
        for(j = i+1;j <= n;j++){
            while(b[j][i]){
                ll tmp=b[i][i]/b[j][i];//不存在除不尽的情况 
                for(k = i;k <= n;k++)
                    b[i][k] -= tmp*b[j][k];
                for(k=i;k<=n;k++)
                    swap(b[i][k],b[j][k]);  
                ret = -ret;
            }
        }
        if(!b[i][i]) return 0;
        ret *= b[i][i];
    }
    if(ret < 0) ret = -ret;
    return ret;
}
	\end{lstlisting}
	\section{割点及桥}
	\subsection{求出割点及桥}
	\begin{lstlisting}
void init(){
    T=0;tot=0;
    memset(head,-1,sizeof(head));
    memset(cut,0,sizeof(cut));
    memset(dfn,0,sizeof(dfn));
    memset(bri,0,sizeof(bri));
}
void Tarjan(int u,int pre){
    dfn[u]=low[u]=++T;
    int son=0;
    for(int i=head[u];i!=-1;i=e[i].next){
        int v=e[i].v;
        if(v==pre) continue ;
        if(!dfn[v]){
            son++;//起点有效儿子
            Tarjan(v,u);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]&&u!=pre)cut[u]=1;
            if(low[v]>dfn[u]){
                bri[i]=1;bri[i^1]=1;
            }
        }else{
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(u==pre && son>1) cut[u]=1;
}
	\end{lstlisting}
	\subsection{无向图缩点成树}
	核心思想，保留割点，其余用并查集联通，最终树上的点一定由割点和环构成。
	\begin{lstlisting}
int T,tot,cnt;
int dfn[N],low[N],cut[N],num[N],f[N];
void adde(int u,int v){
    e[tot].u=u;e[tot].v=v;e[tot].next=head[u];head[u]=tot++;
}
void init(){
    T=0;tot=0;cnt=0;
        return f[x]==x?f[x]:f[x]=find(f[x]);
    }
    void Union(int x,int y){
        int fx=find(x),fy=find(y);
        if(fx!=fy) f[fx]=fy;
    }
    void Tarjan(int u,int pre){
        dfn[u]=low[u]=++T;
        int k=0;
        for(int i=head[u];i!=-1;i=e[i].next){
    memset(head,-1,sizeof(head));
    memset(cut,0,sizeof(cut));
    memset(dfn,0,sizeof(dfn));
    memset(num,0,sizeof(num));
    for(int i=0;i<=n+1;i++) f[i]=i;
}
int find(int x){
        int v=e[i].v;
        if(v==pre && !k){//处理重边，重边会考虑 
            k=1;
            continue ;
        }
        if(!dfn[v]){
            Tarjan(v,u);
            low[u]=min(low[u],low[v]);
        }else{
            low[u]=min(low[u],dfn[v]);
        }
        if(low[v]>dfn[u]){
            cut[v]=1;//割点 
        }else Union(u,v);
    }
} 
	\end{lstlisting}
	\section{二分图}
	\subsection{最大匹配}
	最大匹配=最小点覆盖=最小路径覆盖=顶点数-最大独立集
	
	二分图的最大团=补图的最大独立集（图不一定是二分图）
	
	以下是匈牙利算法，也可以网络流做，效率更高：
	\begin{lstlisting}
int match[N],check[N]; 
int dfs(int x,int nown){
    for(int i=1;i<=nown;i++){
        if(!check[i] && link[x][i]){
            check[i]=1;
            if(match[i]==-1 || dfs(match[i],nown)){
                match[i]=x;
                return 1;
            }
        }
    }
    return 0;
}
int hungry(int n1,int m1){
    memset(match,-1,sizeof(match));
    int ans=0;
    for(int i=1;i<=n1;i++){
        memset(check,0,sizeof(check));
        ans+=dfs(i,m1);
    }
    return ans ;
} 
	\end{lstlisting}
	\section{最大团}
	一般图的做法就是爆搜+减枝，这是个NPC问题。
	
	注意独立集和团的转换。
	\begin{lstlisting}
int link[N][N],vis[N],group[N],cnt[N];
int ans ;
int dfs(int x,int tot){
    for(int i=x+1;i<=n;i++){
        if(cnt[i]+tot<=ans) return 0;//剪枝1 
        if(link[x][i]){
            int flag = 0;
            for(int j=0;j<tot;j++){
                if(!link[i][vis[j]]) flag=1;
            }
            if(!flag){
                vis[tot]=i;
                if(dfs(i,tot+1)) return 1;//剪枝2 
            }
        }
    }
    if(tot>ans){
        ans=tot;
        for(int i=0;i<tot;i++) group[i]=vis[i];
        return 1;
    }
    return 0;
}
void maxclique(){
    ans=-1;
    memset(cnt,0,sizeof(cnt));
    for(int i=n;i>=1;i--){
        vis[0]=i;
        dfs(i,1);
        cnt[i]=ans;
    }
}
	\end{lstlisting}
	\section{支配树}
	在DAG中，可以直接利用性质来构造，一个点的支配点就为所有能到达它的点在支配树上的LCA，比较好理解。
	
	下面给出一般图构造支配树的算法
	\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5, M = 3e5 + 5;

namespace LT{
    vector <int> G[N], rG[N];
    vector <int> dt[N];     //dominant tree
    int fa[N], best[N], T, n;
    int semi[N], idom[N], dfn[N], idx[N], f[N];
    void init() {
        T = 0;
        for(int i = 1; i <= n; i++) semi[i] = f[i] = best[i] = i;
        for(int i = 1; i <= n; i++) dt[i].clear();
    }
    void dfs(int u) {
        dfn[u] = ++T; idx[T] = u;;
        for(auto v : G[u]) {
            if(!dfn[v]) {
                fa[v] = u; dfs(v);
            }
        }
    }
    int find(int x) {
        if(f[x] == x) return x;
        int fx = find(f[x]);
        if(dfn[semi[best[f[x]]]] < dfn[semi[best[x]]]) best[x] = best[f[x]];
        return f[x] = fx;
    }
    void Tarjan(int rt) {
        dfs(rt);
        for(int i = T; i >= 2; i--) {
            int x = idx[i];
            for(int &u : rG[x]) {
                if(!dfn[u]) continue; //可能原图不能到达
                find(u);
                if(dfn[semi[x]] > dfn[semi[best[u]]]) semi[x] = semi[best[u]];
            }
            f[x] = fa[x];
            dt[semi[x]].push_back(x);
            x = fa[x];
            for(int &u : dt[x]) {
                find(u);
                if(semi[best[u]] != x) idom[u] = best[u];
                else idom[u] = x;
            }
            dt[x].clear();
        }
        for(int i = 2; i <= T; i++) {
            int x = idx[i];
            if(idom[x] != semi[x]) idom[x] = idom[idom[x]];
            dt[idom[x]].push_back(x);
        }
    }
}
int n, m;
int sz[N];
void dfs(int u, int fa) {
    sz[u] = 1;
    for(auto v : LT::dt[u]) {
        if(v == fa) continue;
        dfs(v, u);
        sz[u] += sz[v];
    }
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    LT::n = n;
    LT::init();
    for(int i = 1; i <= m; i++) {
        int u, v; cin >> u >> v;
        LT::G[u].push_back(v);
        LT::rG[v].push_back(u);
    }
    LT::Tarjan(1);
    dfs(1, -1);
    for(int i = 1; i <= n; i++) cout << sz[i] << ' ';
    return 0;
}
	\end{lstlisting}
	\chapter{数学}
	\section{素数}
	\subsection{线性筛}
	线性筛，每个数都只被其最小质因子筛一次，复杂度$O(n)$。
	\begin{lstlisting}
for(int i = 2; i <= n; i++) {
    if(!chk[i]) {
        prime[++tot] = i;
    }
    for(int j = 1; j <= tot && 1ll * i * prime[j] <= n; j++) {
        chk[i * prime[j]] = 1;
        if(i % prime[j] == 0) break;
    }
}
	\end{lstlisting}
	\subsection{Miller-Rabin素数测试}
	\begin{lstlisting}
//记得初始化随机种子
ll mul(ll a, ll b, ll p) {
    a %= p, b %= p;
    ll ans = 0;
    while(b) {
        if(b & 1) {
            ans = ans + a;
            if(ans > p) ans -= p;
        }
        a = a + a;
        if(a > p) a -= p;
        b >>= 1;
    }
    return ans;
}
ll qp(ll a, ll b, ll p) {
    ll ans = 1; a %= p;
    while(b) {
        if(b & 1) ans = mul(ans, a, p);
        a = mul(a, a, p);
        b >>= 1;
    }
    return ans;
}
bool check(ll a, ll n, ll x, ll t) {
    ll ans = qp(a, x, n);
    ll last = ans;
    for(int i = 1; i <= t; i++) {
        ans = mul(ans, ans, n);
        if(ans == 1 && last != 1 && last != n - 1) return true;
        last = ans;
    }
    if(ans != 1) return true;
    return false;
}
bool Miller_Rabin(ll n) {
    if(n == 1 || (n & 1) == 0) return false;
    if(n == 2) return true;
    ll x = n - 1, t = 0;
    while((x & 1) == 0) {x >>= 1, ++t;}
    srand(time(NULL));
    for(int i = 0; i < 8; i++) {
        ll a = rand() % (n - 1) + 1;
        if(check(a, n, x, t)) return false;
    }
    return true;
} 
	\end{lstlisting}
	\section{欧几里得算法}
	\subsection{扩展欧几里得}
	求解$ax+by=c,gcd(a,b)|c$的整数解$x,y$，设$g=gcd(a,b)$，通解为$x=x+k*\frac{b}{g},y=y-k*\frac{a}{g}$，最后的解$x=x*c/g,y=y*c/g$。
	\begin{lstlisting}
void exgcd(ll a, ll b, ll &x, ll &y) {
    if(b == 0) {
        x = 1, y = 0;
        return ;
    }
    exgcd(b,a%b,x,y);
    ll z = x ;
    x = y;
    y = z - y * (a / b);
} 
	\end{lstlisting}
	\subsection{类欧几里得}
	求解$\sum_{i=0}^n \lfloor\frac{ai+b}{c}\rfloor$。
	
	形象来说，问题转换为求直线下方整点数，然后不断坐标变换，让直线斜率变得更平缓。
	
	复杂度为$O(logn)$。
	\begin{lstlisting}
const int MOD = 1000000007, inv2 = (MOD + 1) / 2;
ll f(ll n, ll a, ll b, ll c) {
	//sum_{i=0}^n (ai+b)/c
    if(a <= 0) return 0;
    if(a >= c || b >= c) {
        return (n * (n + 1) % MOD * inv2 % MOD * (a / c) % MOD
        + (n + 1) * (b / c) % MOD + f(n, a % c, b % c, c)) % MOD;
    }
    ll m = (a * n + b) / c;
    return (m * n % MOD - f(m - 1, c, c - b - 1, a) + MOD) % MOD;
} 
	\end{lstlisting}
	
	求解最小的$x,y$，使得$\frac{a}{b}\leq \frac{x}{y}\leq \frac{c}{d}$。
	
	类欧几里得的一个应用，详细证明见:https://www.cnblogs.com/heyuhhh/p/11310342.html
	
	\begin{lstlisting}
void gao(ll a, ll b, ll c, ll d, ll &x, ll &y) { // a/b < x/y < c/d
    ll t = (a + b - 1) / b;
    if(c / d >= t) {
        y = 1; x = t;
        return;
    }
    a -= (t - 1) * b;
    c -= (t - 1) * d;
    gao(d, c, b, a, y, x);
    x += (t - 1) * y;
}
	\end{lstlisting}
	\section{线性递推求逆元}
	求$1,\dots,p-1$模$p$的所有逆元，有公式：$inv[i]=(p-p/i)*inv[p\%i]\%m$
	
	证明：设$t=\frac{p}{i},k=p\%i$，就有$t*i+k\equiv 0(\% p)$即$t*i\equiv -k(\% p)$，两边同时除以$i*k$就出来了。
	
	代码略。
	\section{高斯消元}
	若秩小于$n$，则有无穷多组解，但首先排除无解的情况。
	
	以下给出高斯消元求同余模方程组的代码。
	\begin{lstlisting}
int now = 1;
for(int i = 1 ; i <= n ; i++) {
    int j = now ;
    while(j <= m && !a[j][i]) j++;
    if(j > m) continue ;
    if(j != now) {	
        for(int k = 1 ; k <= n + 1 ; k++) {
            swap(a[now][k] , a[j][k]) ;
        }
    }
    for(int j = now + 1 ; j <= m ; j++)
        if(a[j][i]) {
            int t = a[j][i] * inv[a[now][i]] % MOD;
            for(int k = i ; k <= n + 1 ; k++) {
                a[j][k] = (((a[j][k] - t * a[now][k]) % MOD) + MOD) % MOD;
            }
        }
    now++;
} 
	\end{lstlisting}
	\section{欧拉函数}	
	$\varphi (x)=x\prod_{i=1}^{n}(1-\frac{1}{p_i})$
	
	$\varphi * I = id$
	
	$phi(p^k)=p^k-p^{k-1}$
	\subsection{求$\varphi (n)$}
	\begin{lstlisting}
int getphi(int x) {
    int ans = x;
    for(int i = 2; 1ll * i * i <= x; i++) {
        if(x % i == 0) {
            ans = ans / i * (i - 1);
            while(x % i == 0) x /= i;
        }
    }
    if(x > 1) ans = ans / x * (x - 1);
    return ans;
}
	\end{lstlisting}
	\subsection{线性筛}
	\begin{lstlisting}
int p[N], phi[N], tot;
bool chk[N];
void Euler() {
    phi[1] = 1;
    for(int i = 2; i < N; i++) {
        if(!chk[i]) p[++tot] = i, phi[i] = i - 1;
        for(int j = 1; j <= tot && i * p[j] < N; j++) {
            chk[i * p[j]] = 1;
            if(i % p[j] == 0) {
                phi[i * p[j]] = phi[i] * p[j];
                break;
            }
            phi[i * p[j]] = phi[i] * (p[j] - 1);
        }
    }
}
	\end{lstlisting}
	\section{莫比乌斯函数}
	$$
	\mu=\left\{
	\begin{aligned}
	0,&\text{存在平方因子}\\
	-1,&\text{奇数个质因子}\\
	1,&\text{偶数个质因子}
	\end{aligned}
	\right.
	$$
	
	$\sum_{d|n}\mu(d)=[n=1]$
	
	
	莫比乌斯反演：
	
	形式一：已知$g(n)=\sum_{d|n}f(d)$，则$f(n)=\sum_{d|n}\mu(d)\cdot g(\frac{n}{d})$
	
	形式二：已知$g(n)=\sum_{n|d}f(d)$，则$f(n)=\sum_{d|n}\mu(\frac{d}{n})\cdot g(d)$
	线性筛:
	\begin{lstlisting}
int mu[N], p[N];
bool chk[N];
void init() {
    mu[1] = 1;
    int cnt = 0;
    for(int i = 2; i < N; i++) {
        if(!chk[i]) p[++cnt] = i, mu[i] = -1;
        for(int j = 1; j <= cnt && i * p[j] <= k; j++) {
            chk[i * p[j]] = 1;
            if(i % p[j] == 0) {mu[i * p[j]] = 0; break;}
            mu[i * p[j]] = -mu[i];
        }
    }
} 
	\end{lstlisting}
	\section{整除分块}
	求解$\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$。
	\begin{lstlisting}
int ans = 0;
for(int i = 1, j; i <= n; i = j + 1) {
    j = n / (n / i);
    ans += (j - i + 1) * (n / i);
}
	\end{lstlisting}
	\section{杜教筛}
	求解$S(n)=\sum_{i=1}^n f(i),f$为积性函数。
	
	构造$h=f*g$，最后有$g(1)\cdot S(n)=\sum_{i=1}^n (f*g)(i)-\sum_{d=2}^n g(d)S(\lfloor\frac{n}{d}\rfloor)$
	暴力递归即可。
	
	可预处理前$\frac{1}{3}$项，复杂度$O(n^\frac{2}{3})$，注意记忆化。
	
	下面给出筛欧拉函数和莫比乌斯函数的代码。
	\begin{lstlisting}
ll djs_mu(int n) {
    if(n <= 5000000) return mu[n];
    if(mp1[n]) return mp1[n];
    ll ans = 1;
    for(int i = 2, j; i <= n; i = j + 1) {
        j = n / (n / i);
        ans -= (j - i + 1) * djs_mu(n / i);
    }
    return mp1[n] = ans;
}
ll djs_phi(int n) {
    if(n <= 5000000) return phi[n];
    if(mp2[n]) return mp2[n];
    ll ans = 1ll * (n + 1) * n / 2;
    for(int i = 2, j; i <= n; i = j + 1) {
        j = n / (n / i);
        ans -= (j - i + 1) * djs_phi(n / i);
    }
    return mp2[n] = ans;
}
	\end{lstlisting}
	\section{min25筛}
	求解一类积性函数的前缀和，此类积性函数满足在$p^k$处的值容易计算，并且$f(p)$为一个与$p$有关的简单多项式。
	
	$$g(n,j)=g(n,j-1)-f(p_j)*(g(\frac{n}{p_j},j-1)-sum_{j-1})$$
	
	$$S(i,j)=g(i,|P|)-sum_{j-1}+\sum_{k\geq j}\sum_{e}F(p_k^e)(S(\frac{i}{p_k^e},k+1)+[e\not ={1}])$$
	
	$g(n,j):1\cdots n$中，全为质数或者最小质因子大于第$j$个质数的数之和；$S(i,j):1\cdots i$中，最小质因子大于等于第$j$个质数的数之和。
	
	最终答案为$S(n,1)+f(1)$。
	
	\begin{lstlisting}
//注意1单独考虑
//g应为完全积性函数，在质数处与f相等
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e6 + 5, MOD = 1e9 + 7, inv3 = 333333336;
ll n;
ll sum1[N], sum2[N], prime[N];
ll w[N], ind1[N], ind2[N];
ll g1[N], g2[N];
bool chk[N];
int tot, cnt;
void pre(int n) { //  \sqrt
    chk[1] = 1;
    for(int i = 1; i <= n; i++) {
        if(!chk[i]) {
            prime[++tot] = i;
            sum1[tot] = (sum1[tot - 1] + i) % MOD;
            sum2[tot] = (sum2[tot - 1] + 1ll * i * i % MOD) % MOD;
        }
        for(int j = 1; j <= tot && prime[j] * i <= n; j++) {
            chk[i * prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
void calc_g() {
    int z = sqrt(n);
    for(ll i = 1, j; i <= n; i = j + 1) {
        j = n / (n / i);
        w[++cnt] = n / i;
        g1[cnt] = w[cnt] % MOD;
        g2[cnt] = g1[cnt] * (g1[cnt] + 1) / 2 % MOD * (2 * g1[cnt] + 1) % MOD * inv3 % MOD - 1;
        g1[cnt] = g1[cnt] * (g1[cnt] + 1) / 2 % MOD - 1;
        if(n / i <= z) ind1[n / i] = cnt;
        else ind2[n / (n / i)] = cnt;
    }
    for(int i = 1; i <= tot; i++) {
        for(int j = 1; j <= cnt && prime[i] * prime[i] <= w[j]; j++) {
            ll tmp = w[j] / prime[i], k;
            if(tmp <= z) k = ind1[tmp]; else k = ind2[n / tmp];
            (g1[j] -= prime[i] * (g1[k] - sum1[i - 1] + MOD) % MOD) %= MOD;
            (g2[j] -= prime[i] * prime[i] % MOD * (g2[k] - sum2[i - 1] + MOD) % MOD) %= MOD;
            if(g1[j] < 0) g1[j] += MOD;
            if(g2[j] < 0) g2[j] += MOD;
        }
    }
}
ll S(ll x, int y) { // 2~x >= P_y
    if(x <= 1 || prime[y] > x) return 0;
    ll z = sqrt(n);
    ll k = x <= z ? ind1[x] : ind2[n / x];
    ll ans = (g2[k] - g1[k] + MOD - (sum2[y - 1] - sum1[y - 1]) + MOD) % MOD;
    for(int i = y; i <= tot && prime[i] * prime[i] <= x ; i++) {
        ll pe = prime[i], pe2 = prime[i] * prime[i];
        for(int e = 1; pe2 <= x; ++e, pe = pe2, pe2 *= prime[i]) {
            ans = (ans + pe % MOD * ((pe - 1) % MOD) % MOD * S(x / pe, i + 1) + pe2 % MOD * ((pe2 - 1) % MOD) % MOD) % MOD;
        }
    }
    return ans % MOD;
}
int main() {
    cin >> n;
    int tmp = sqrt(n);
    pre(tmp);
    calc_g();
    cout << (S(n, 1) + 1) % MOD ;
    return 0;
}
	\end{lstlisting}
	\section{中国剩余定理}
	\begin{lstlisting}
struct CRT{
    void exgcd(ll a, ll b, ll &g, ll &x, ll &y) {
        if(b == 0) {
            x = 1, y = 0, g = a;
            return ;
        }
        exgcd(b, a % b, g, x, y);
        int t = x;
        x = y;
        y = t - (a / b) * y;
    }
    ll china(ll m[], ll a[], int n) {
        ll M, Mi, d, X, Y, ans;
        M = 1; ans = 0;
        for(int i = 1; i <= n; i++) M *= m[i];
        for(int i = 1; i <= n; i++) {
            Mi = M / m[i];
            exgcd(Mi, m[i], d, X, Y);
            ans = (ans + Mi * X * a[i]) % M;
        }
        if(ans < 0) ans += M;
        return ans;
    }
}crt;
	\end{lstlisting}
	
	扩展中国剩余定理可以处理模数不互质的情况，直接类似于数学归纳法合并解即可。
	
	\section{BSGS}
	求解高次同余方程$a^x\equiv b\mod m$
	
	令$x=i*t+j,t=\sqrt{m}$，分块处理即可。
	\begin{lstlisting}
//预处理$a^j$，之后将逆元乘过去
//v=$\frac{1}{a^t}$
struct B{
    const int mod = 524287; // (1 << 19) - 1;
    int tot;
    int h[524288], next[524288], L[524288], v[524288];
    int Find(ll x) {
        int k = h[x & mod];
        while(k != 0) {
            if(L[k] == x) return v[k];
            else k = next[k];
        }
        return -1;
    }
    void Add(int e, int i) {
        tot++;
        next[tot] = h[e & mod];
        L[tot] = e; v[tot] = i;
        h[e & mod] = tot;
    }
    void init(int a, int n) {
        memset(h, 0, sizeof(h)); memset(L, 0, sizeof(L));tot = 0;
        memset(next, 0, sizeof(next)); memset(v, 0, sizeof(v));
        ll t, e = 1;
        t = (int)sqrt(n) + 1;
        for(int i = 0; i < t; i++) {
            if(Find(e) == -1) Add(e, i);
            e = e * a % n;
        }
    }
    ll BSGS(int a, int b, int n, ll v, ll t) { // a ^ x = b (mod n)
        for(int i = 0; i < t; i++) {
            if(Find(b) != -1) return i * t + Find(b);
            b = b * v % n;
        }
        return -1;
    }
}S;
	\end{lstlisting}
	\section{二次剩余}
	若$a^{\frac{p-1}{2}}\equiv 1\mod p$，那么$a$为模$p$的二次剩余。
	若$a^{\frac{p-1}{2}}\equiv -1\mod p$，则$a$为模$p$的非二次剩余。
	若$a^{\frac{p-1}{2}}\equiv 0\mod p$，则$p|a$。
	
	\section{欧拉降幂}
	$$
	a^b\equiv\left\{
	\begin{aligned}
	    &a^{b\% \varphi(p)},  &gcd(a,p)=1\\
	    &a^b,   &gcd(a,p)\not ={1},b<\varphi(p)\\
	    &a^{\varphi(p)+b\%\varphi(p)},    &gcd(a,p)\not ={1},b >= \varphi(p)
	\end{aligned}
	\ \ \ \ \ (mod\ p)
	\right.
	$$
	求$a^{a^{a^{\cdots ^a}}}\%p$代码如下：(注意快速幂部分，如果指数大于$p$了，应当保留一个$p$)
	\begin{lstlisting}
ll Mod(ll a, ll b) { //可以直接避免分类讨论
    return a < b ? a : a % b + b;
}
int qp(ll a, ll b, ll p) {
    int ans = 1;
    while(b) {
        if(b & 1) ans = Mod(ans * a, p);
        a = Mod(a * a, p);
        b >>= 1;
    }
    return ans;
}
int calc(ll a, ll b, ll m) {
    if(m == 1 || !b) return 1;
    int p = phi[m];
    int x = calc(a, b - 1, p);
    return qp(a, x, m);
}
	\end{lstlisting}
	\section{FFT}
	\begin{lstlisting}
const double pi = acos(-1.0);
struct C{
    double x, y;
    C (double xx = 0, double yy = 0) {x = xx, y = yy;}
}a[N], b[N], c[N];
C operator + (C a, C b) {return C(a.x + b.x, a.y + b.y);}
C operator - (C a, C b) {return C(a.x - b.x, a.y - b.y);}
C operator * (C a, C b) {return C(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}
int l, r[N];
int lim = 1;
void solve(C *A, int type) {
    for(int i = 0; i < lim; i++) if(i < r[i]) swap(A[i], A[r[i]]);
    for(int mid = 1; mid < lim; mid <<= 1) {
        C Wn(cos(pi / mid), type * sin(pi / mid)) ;
        for(int R = mid << 1, j = 0; j < lim; j += R) {
            C w(1, 0);
            for(int k = 0; k < mid; k++, w = w * Wn) {
                C x = A[j + k], y = w * A[j + mid + k];
                A[j + k] = x + y;
                A[j + mid + k] = x - y;
            }
        }
    }
}
void FFT(C *a, C *b) {
    while(lim <= n + m) lim <<= 1, l++;
    for(int i = 0; i < lim; i++) {
        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    }
    for(int i = n + 1; i < lim; i++) a[i] = C();
    for(int i = m + 1; i < lim; i++) b[i] = C();
    solve(a, 1); solve(b, 1);
    for(int i = 0; i <= lim; i++) c[i] = a[i] * b[i];
    solve(c, -1);
    for(int i = 0; i <= n + m; i++) c[i].x = (c[i].x / lim + 0.5);
}
	\end{lstlisting}
	\section{NTT}
	有模数版FFT，模数一般为998244353。
	\begin{lstlisting}
const int N = 4e5 + 5, M = 2e6 + 5, P = 998244353, G = 3, Gi = 332748118;
int n, m, lim = 1, L, r[N];
ll a[N], b[N];
ll qp(ll a, ll k) {
    ll ans = 1;
    while(k) {
        if(k & 1) ans = (ans * a ) % P;
        a = (a * a) % P;
        k >>= 1;
    }
    return ans;
}
void NTT(ll *A, int type) {
    for(int i = 0; i < lim; i++)
        if(i < r[i]) swap(A[i], A[r[i]]);
    for(int mid = 1; mid < lim; mid <<= 1) {
        ll Wn = qp( type == 1 ? G : Gi , (P - 1) / (mid << 1)); //Wn = g ^ ((p - 1) / n)  (mod p)
        for(int j = 0; j < lim; j += (mid << 1)) {
            ll w = 1;
            for(int k = 0; k < mid; k++, w = (w * Wn) % P) {
                 int x = A[j + k], y = w * A[j + k + mid] % P;
                 A[j + k] = (x + y) % P,
                 A[j + k + mid] = (x - y + P) % P;
            }
        }
    }
}
void solve(ll *a, ll *b) {
    while(lim <= n + m) lim <<= 1, L++;
    for(int i = 0; i < lim; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));
    for(int i = n + 1; i < lim; i++) a[i] = 0;  //a,b need init
    for(int i = m + 1; i < lim; i++) b[i] = 0;
    NTT(a, 1); NTT(b, 1);
    for(int i = 0; i < lim; i++) a[i] = (a[i] * b[i]) % P;
    NTT(a, -1);
    ll inv = qp(lim, P - 2);
    for(int i = 0; i < lim; i++) a[i] = a[i] * inv % P;
}
	\end{lstlisting}
	\section{蔡勒公式}
	快速判断一天为星期几。
	\begin{lstlisting}
bool check(int k) {
    int y = 0, m = 0, d = 0;
    for(int i = 0; i < 4; i++) y = y * 10 + (a[s[k][i] - 'A']);
    for(int i = 5; i < 7; i++) m = m * 10 + (a[s[k][i] - 'A']);
    for(int i = 8; i < 10; i++) d = d * 10 + (a[s[k][i] - 'A']);
    if(y < 1600 || y > 9999 || m > 12 || d > 31) return false;
    if((m == 2 && d > 28 + (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)))) return false;
    if(m != 2 && d > days[m]) return false;
    if(m < 3) y--, m += 12;
    return (y + y / 4 - y / 100 + y / 400 + d + 1 + 2 * m + 3 * (m + 1) / 5) % 7 == 5; //年份大于1582
	return (y + y / 4 + 5 + 3 * (m + 1) / 5 + d + 2 * m) % 7 //年份小于1582 
}
	\end{lstlisting}
	\section{原根}
	\begin{lstlisting}
ll qp(ll a, ll b) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return ans;
}
int work(ll P) {   //p - 1
    vector <int> div;
    for(int i = 2; 1ll * i * i <= P; i++) {
        if(P % i == 0) {
            div.push_back(i);
            while(P % i == 0) P /= i;
        }
    }
    if(P > 1) div.push_back(P);
    for(int i = 2;; i++) {
        bool ok = true;
        for(auto x : div) {
            if(qp(i, (p - 1) / x) % p == 1) {
                ok = false; break;
            }
        }
        if(ok) return i;
    }
} 
	\end{lstlisting}
	\section{二次剩余}
	\begin{lstlisting}
//求解x^2=n(mod p)
const int moder = (int) 1e9 + 7;
const int inv2 = (moder + 1) / 2;
 
struct field2{
    int x, y, a, p;
 
    field2():x(0), y(0), a(0), p(0){}
    field2(int x, int y, int a, int p):x(x), y(y), a(a), p(p){}
 
    field2 operator *(const field2 &f)const{
        int retx = (1ll * x * f.x + 1ll * y * f.y % p * a) % p;
        int rety = (1ll * x * f.y + 1ll * y * f.x) % p;
        return field2(retx, rety, a, p);
    }
 
    field2 powermod(int exp)const{
        field2 ret(1, 0, a, p), aux = *this;
        for ( ; exp > 0; exp >>= 1){
            if (exp & 1){
                ret = ret * aux;
            }
            aux = aux * aux;
        }
        return ret;
    }
};
 
int powermod(int a, int exp, int moder){
    int ret = 1;
    for ( ; exp; exp >>= 1){
        if (exp & 1){
            ret = 1ll * ret * a % moder;
        }
        a = 1ll * a * a % moder;
    }
    return ret;
}
 
int randint(int n){
    return rand() % n;
}
vector <int> remain2(int a, int p){ //x^2 = a (mod p)
    if (!a || p == 2){ //特判 
        return {a, a};
    }
    if (powermod(a, p - 1 >> 1, p) != 1){ //欧拉准则 
        return {};
    }
    while (true){
        field2 f(randint(p - 1) + 1, randint(p - 1) + 1, a, p);
        f = f.powermod(p - 1 >> 1);
        if (f.x){
            continue;
        }
        int ret = powermod(f.y, p - 2, p);
        return {ret, p - ret};
    }
} 
	\end{lstlisting}
	\section{拉格朗日插值}
	对于一个$n$次多项式，如果已知其$n+1$项，那么就可以快速求解其他项，若那$n+1$项连续，则可以通过预处理阶乘，复杂度达到$O(n)$。
	
	常见应用就为求解$\sum_{i=1}^{n}i^k$，这是一个以$n$为自变量的$k+1$次多项式，应用拉格朗日插值复杂度为$O(k)$。

	\begin{figure}[!htb]
		\centering
		\includegraphics[width=0.9\textwidth]{chafen}    % 当前tex文件同一目录下名为icpc的任意格式图片
	\end{figure}

	\begin{lstlisting}
struct Lagrange {
	static const int SIZE = 110;
	ll f[SIZE], fac[SIZE], inv[SIZE], pre[SIZE], suf[SIZE];
	int n;
	inline void add(int &x, int y) {
		x += y;
		if(x >= MOD) x -= MOD;
	}
	void init(int _n) {
		n = _n;
		fac[0] = 1;
		for (int i = 1; i < SIZE; ++i) fac[i] = fac[i - 1] * i % MOD;
	    inv[SIZE - 1] = qp(fac[SIZE - 1], MOD - 2);
		for (int i = SIZE - 1; i >= 1; --i) inv[i - 1] = inv[i] * i % MOD;
		//设置f初值，可以根据需要修改
		f[0] = 0;
		for (int i = 1; i <= n; ++i)
			f[i] = (f[i - 1] + qp(i, K)) % MOD;
	}
	ll calc(ll x) {
		if (x <= n) return f[x];
		pre[0] = x % MOD;
		for (int i = 1; i <= n; ++i) pre[i] = pre[i - 1] * ((x - i) % MOD) % MOD;
		suf[n] = (x - n) % MOD;
		for (int i = n - 1; i >= 0; --i) suf[i] = suf[i + 1] * ((x - i) % MOD) % MOD;
		ll res = 0;
		for (int i = 0; i <= n; ++i) {
			ll tmp = f[i] * inv[n - i] % MOD * inv[i] % MOD;
			if (i) tmp = tmp * pre[i - 1] % MOD;
			if (i < n) tmp = tmp * suf[i + 1] % MOD;
			if ((n - i) & 1) tmp = MOD - tmp;
			add(res, tmp);
		}
		return res;
	}
}lagrange;
	\end{lstlisting}
	\section{BM线性递推}
	若递推式由前$k$项推出，我们只需要求出前$2k$项，然后传入就行，能够快速求解第$n$项，复杂度为$O(klogn)$。
	\begin{lstlisting}
#include<bits/stdc++.h>
#define rep(i,a,n) for (int i=a;i<n;i++)
#define SZ(x) ((int)(x).size())
const int MAXN = 2e5 + 5, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
using namespace std;
#define lson o<<1,l,m
#define rson o<<1|1,m+1,r
#define mid l + ((r-l)>>1)
#define pb push_back
 
typedef vector<int> VI;
typedef long long ll;
 
ll powMOD(ll a, ll b) {
    ll ans = 1;
    for (; b; b >>= 1, a = a * a%MOD)if (b & 1)ans = ans * a%MOD;
    return ans;
}
ll n;
namespace linear_seq {
    const int N = 10010;
    ll res[N], base[N], _c[N], _md[N];
 
    vector<int> Md;
    void mul(ll *a, ll *b, int k) {
        rep(i, 0, k + k) _c[i] = 0;
        rep(i, 0, k) if (a[i]) rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % MOD;
        for (int i = k + k - 1; i >= k; i--) if (_c[i])
            rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % MOD;
        rep(i, 0, k) a[i] = _c[i];
    }
    int solve(ll n, VI a, VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
        ll ans = 0, pnt = 0;
        int k = SZ(a);
        assert(SZ(a) == SZ(b));
        rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1;
        Md.clear();
        rep(i, 0, k) if (_md[i] != 0) Md.push_back(i);
        rep(i, 0, k) res[i] = base[i] = 0;
        res[0] = 1;
        while ((1ll << pnt) <= n) pnt++;
        for (int p = pnt; p >= 0; p--) {
            mul(res, res, k);
            if ((n >> p) & 1) {
                for (int i = k - 1; i >= 0; i--) res[i + 1] = res[i]; res[0] = 0;
                rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % MOD;
            }
        }
        rep(i, 0, k) ans = (ans + res[i] * b[i]) % MOD;
        if (ans < 0) ans += MOD;
        return ans;
    }
    VI BM(VI s) {
        VI C(1, 1), B(1, 1);
        int L = 0, m = 1, b = 1;
        rep(n, 0, SZ(s)) {
            ll d = 0;
            rep(i, 0, L + 1) d = (d + (ll)C[i] * s[n - i]) % MOD;
            if (d == 0) ++m;
            else if (2 * L <= n) {
                VI T = C;
                ll c = MOD - d * powMOD(b, MOD - 2) % MOD;
                while (SZ(C) < SZ(B) + m) C.pb(0);
                rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % MOD;
                L = n + 1 - L; B = T; b = d; m = 1;
            }
            else {
                ll c = MOD - d * powMOD(b, MOD - 2) % MOD;
                while (SZ(C) < SZ(B) + m) C.pb(0);
                rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % MOD;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a, ll n) {
        VI c = BM(a);
        c.erase(c.begin());
        rep(i, 0, SZ(c)) c[i] = (MOD - c[i]) % MOD;
        return solve(n, c, VI(a.begin(), a.begin() + SZ(c)));
    }
};
inline void add(int &x, int y) {
    x += y;
    if (x >= MOD)x -= MOD;
}
int t, k, dp[MAXN];
vector<int> v;
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> t;
    while (t--) {
        v.clear();
        cin >> k >> n;
        if (n == -1) {
            cout << 2 * powMOD(k + 1, MOD - 2) % MOD << '\n';
            continue;
        }
        ll inv = powMOD(k, MOD - 2);
        dp[1] = 1; v.push_back(1);
        for (int i = 2; i <= 2 * k; i++) {
            dp[i] = 0;
            for (int j = max(1, i - k); j < i; j++) {
                add(dp[i], dp[j]);
            }
            dp[i] = dp[i] * inv%MOD;
            v.push_back(dp[i]);
        }
        cout << linear_seq::gao(v, n) << '\n';
    }
    return 0;
}
	\end{lstlisting}
	
	\chapter{字符串}
	\section{KMP}
	\begin{lstlisting}
void Get_next(char *s) {
    int j, L = strlen(s + 1);
    nxt[1] = j = 0;
    for(int i = 2; i <= L; i++) {
        while(j && s[i] != s[j + 1]) j = nxt[j] ;
        if(s[i] == s[j + 1]) j++;
        nxt[i] = j;
    }
}
int L1 = strlen(s1 + 1), L2 = strlen(s2 + 1) ;
for(int i = 1, j = 0; i <= L1; i++) {
    while(j > 0 && (j == L2 || s1[i] != s2[j + 1])) j = nxt[j] ;
    if(s1[i] == s2[j + 1]) j++;
    //if(j == L2) 此时位于末尾 
}
	\end{lstlisting}
	\section{扩展KMP}
	求出一个串的所有后缀与另外一个串的最长公共前缀。
	\begin{lstlisting}
struct ExKmp{
    int Next[N];
    int extend[N];
    void get_next(char *s) {
        int len = strlen(s + 1), p = 1, pos;
        Next[1] = len;
        while(p + 1 <= len && s[p] == s[p + 1]) p++;
        Next[pos = 2] = p - 1;
        for(int i = 3; i <= len; i++) {
            int l = Next[i - pos + 1];
            if(i + l < p + 1) Next[i] = l;
            else {
                int j = max(p - i + 1, 0);
                while(i + j <= len && s[j + 1] == s[i + j]) ++j;
                p = i + (Next[pos = i] = j) - 1;
            }
        }
    }
    void work(char *s, char *t) {
        get_next(t);
        int lens = strlen(s + 1), lent = strlen(t + 1), p = 1, pos;
        while(p <= lent && s[p] == t[p]) ++p;
        p = extend[pos = 1] = p - 1;
        for(int i = 2; i <= lens; i++) {
            int len = Next[i - pos + 1];
            if(len + i < p + 1) extend[i] = len;
            else {
                int j = max(p - i + 1, 0);
                while(i + j <= lens && j <= lent && t[j + 1] == s[i + j]) j++;
                p = i + (extend[pos = i] = j) - 1;
            }
        }
    }
}exkmp;
	\end{lstlisting}
	\section{马拉车算法}
	\begin{lstlisting}
struct Manacher{
    char ch[N << 1];
    int p[N << 1];
    void work(char *s) {
        int l = 0;
        ch[l++] = '&'; ch[l++] = '#';
        for(int i = 0; s[i]; i++) {
            ch[l++] = s[i];
            ch[l++] = '#';
        }
        ch[l] = '\0';
        int mx = 0, id = 0;
        for(int i = 0; i < l; i++) {
            p[i] = i < mx ? min(p[2 * id - i], mx - i) : 1;
            while(ch[i + p[i]] == ch[i - p[i]]) p[i]++;
            if(i + p[i] > mx) mx = i + p[i], id = i;
        }
    }
}Man;
	\end{lstlisting}
	\section{Trie树}
	\begin{lstlisting}
struct Trie{
    int ch[N * 30][2], cnt[N * 30];
    int tot;
    void init() {
        tot = 0;
        ch[tot][0] = ch[tot][1] = 0;
    }
    int New_node() {
        ch[++tot][0] = ch[tot][1] = 0;
        return tot;
    }
    void Insert(int x) {
        int u = 0;
        for(register int i = 29; ~i; --i) {
            int p = ((x >> i & 1) ? 1 : 0);
            if(!ch[u][p]) ch[u][p] = New_node();
            u = ch[u][p];
            ++cnt[u];
        }
    }
}t1, t2;
	\end{lstlisting}
	\section{AC自动机}
	\begin{lstlisting}
queue <int> q;
struct ACAM{
    int sz;
    int ch[N][MAX];
    int cnt[N], fail[N];
    void init() {
        sz = -1;
        newnode();
    }
    int newnode() {
        memset(ch[++sz], 0, sizeof(ch[sz]));
        cnt[sz] = fail[sz] = 0;
        return sz;
    }
    void insert(char *s) {
        int u = 0;
        for(int i = 1; s[i]; i++) {
            int idx = s[i] - 'a';
            if(!ch[u][idx]) ch[u][idx] = newnode();
            u = ch[u][idx];
        }
        cnt[u]++;
    }
    void build() {
        while(!q.empty()) q.pop();
        for(int i = 0; i < 26; i++) {
            if(ch[0][i]) q.push(ch[0][i]);
        }
        while(!q.empty()) {
            int cur = q.front(); q.pop();
            for(int i = 0; i < 26; i++) {
                if(ch[cur][i]) {
                    fail[ch[cur][i]] = ch[fail[cur]][i];
                    q.push(ch[cur][i]);
                } else {
                    ch[cur][i] = ch[fail[cur]][i];
                }
            }
        }
    }
}ac;
	\end{lstlisting}
	\section{字符串hash}
	hash方式有多种，可以视情况来设计hash函数，下面给出最常见的一种：
	\begin{lstlisting}
typedef unsigned long long ull;
template <unsigned mod, unsigned base>
struct rolling_hash {
    unsigned int pg[N], val[N]; // val:1,2...n
    rolling_hash() {
        pg[0] = 1;
        for(int i = 1; i < N; i++) pg[i] = 1ull * pg[i - 1] * base % mod;
        val[0] = 0;
    }
    void build(const char *str) {
        for(int i = 0; str[i]; i++) {
            val[i + 1] = (str[i] + 1ull * val[i] * base) % mod;
        }
    }
    unsigned int operator() (int l, int r) {
        ++r; // 
        return (val[r] - 1ull * val[l] * pg[r - l] % mod + mod) % mod;
    }
};
struct dm_hasher {
    //str:0,1...len-1
    rolling_hash<997137961, 753> h1;
    rolling_hash<1003911991, 467> h2;
    void build(const char *str) {
        h1.build(str); h2.build(str);
    }
    ull operator() (int l, int r) {
        return ull(h1(l, r)) << 32 | h2(l, r);
    }
}hasher;
	\end{lstlisting}
	\section{回文自动机}
	一般用来求解本质不同的回文串相关问题，每个结点到根都代表一个回文后缀。
	
	与AC自动机有点类似。
	\begin{lstlisting}
namespace PAM{
    int ch[N][26], fail[N], len[N], st[N], cnt[N];
    int sz, n, last;
    int New(int l, int f) {
        memset(ch[++sz], 0, sizeof(ch[sz]));
        len[sz] = l, fail[sz] = f;
        return sz;
    }
    void init() {
        sz = -1;
        New(0, 1); last = New(-1, 0);
        st[n = 0] = -1;
        memset(cnt, 0, sizeof(cnt));
    }
    int getf(int x) {
        while(st[n - len[x] - 1] != st[n]) x = fail[x];
        return x;
    }
    bool Insert(int c) { //int
        st[++n] = c;
        int x = getf(last);
        bool F = 0;
        if(!ch[x][c]) {
            F = 1;
            int f = getf(fail[x]);
            ch[x][c] = New(len[x] + 2, ch[f][c]);
        }
        last = ch[x][c];
        cnt[last]++;
        return F;
    }
    void count() {
        for(int i = sz; i >= 1; i--) cnt[fail[i]] += cnt[i];
    }
};
	\end{lstlisting}
	\section{后缀数组}
	\begin{lstlisting}
struct SA{                                       //sa:1...n  Rank:0...n-1
    int x[N], y[N], sa[N], c[N], height[N], Rank[N];
    int f[N][20], lg[N];
    int n;                                          //length
    void da(char *s, int m){
        n++;
        for(int i = 0; i < m; i++) c[i] = 0;
        for(int i = 0; i < n; i++) c[x[i] = s[i]]++;
        for(int i = 1; i < m; i++) c[i] += c[i - 1] ;
        for(int i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;
        for(int k = 1; k <= n; k <<= 1) {
            int p = 0 ;
            for(int i = n - k; i < n; i++) y[p++] = i ;
            for(int i = 0; i < n; i++) if(sa[i] >= k) y[p++] =sa[i] - k;
            for(int i = 0; i < m; i++) c[i] = 0;
            for(int i = 0; i < n; i++) c[x[y[i]]]++;
            for(int i = 1; i < m; i++) c[i] += c[i - 1];
            for(int i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i] ;
            swap(x , y); p = 1; x[sa[0]] = 0;
            for(int i = 1; i < n; i++)
                x[sa[i]] = y[sa[i - 1]] == y[sa[i]] && y[sa[i-1] + k] == y[sa[i] + k] ? p - 1 : p++;
            if(p >= n) break ;
            m = p;
        }
        n--;
        int k = 0;
        for(int i = 0; i <= n; i++) Rank[sa[i]] = i;
        for(int i = 0; i < n; i++) {
            if(k) k--;
            int j = sa[Rank[i] - 1];
            while(s[i + k] == s[j + k]) k++;
            height[Rank[i]] = k;
        }
    }
    ll count() {
        ll ans = 0;
        for(int i = 1; i <= n; i++) ans += n - sa[i] - height[i];
        return ans;
    }
    void init() {
        for(int i = 2; i < N; i++) lg[i] = lg[i >> 1] + 1;
        for(int i = 2; i <= n; i++) f[i][0] = height[i];
        for(int j = 1; j < 20; j++)
            for(int i = 2; i + (1 << j) - 1 <= n; i++)
                f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]) ;
    }
    int get_lcp(int l, int r) {
        if(Rank[l] > Rank[r]) swap(l, r);
        l = Rank[l] + 1, r = Rank[r];
        int k = lg[r - l + 1];
        return min(f[l][k], f[r - (1 << k) + 1][k]);
    }
}
	\end{lstlisting}
	\section{后缀自动机}
	以一道例题为例，做法是$dp$+后缀自动机，用后缀自动机维护最远的那个位置来进行转移。
	\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4e5 + 5;
int p, q;
char s[N];
struct SAM{
    struct node{
        int ch[26];
        int len, fa;
        node(){memset(ch, 0, sizeof(ch)), len = 0;}
    }dian[N];
    int last, tot, now; //now为在后缀自动机上跑的一个指针
    void init(int n) {
        last = tot = now = 1;
        for(int i = 1; i <= 2 * n; i++) {
            for(int j = 0; j < 26; j++) dian[i].ch[j] = 0;
            dian[i].len = 0;
        }
    }
    void add(int c) { //核心部分
        int p = last;
        int np = last = ++tot;
        dian[np].len = dian[p].len + 1;
        for(; p && !dian[p].ch[c]; p = dian[p].fa) dian[p].ch[c] = np;
        if(!p) dian[np].fa = 1;
        else {
            int q = dian[p].ch[c];
            if(dian[q].len == dian[p].len + 1) dian[np].fa = q;
            else {
                int nq = ++tot; dian[nq] = dian[q];
                dian[nq].len = dian[p].len + 1;
                dian[q].fa = dian[np].fa = nq;
                for(; p && dian[p].ch[c] == q; p = dian[p].fa) dian[p].ch[c] = nq;
            }
        }
    }
    void withdraw(int lens) { //越短个数越多
        while(now && dian[dian[now].fa].len >= lens) now = dian[now].fa;
        if(now == 0) now = 1;
    }
    void trans(int t, int lens) {
        now = dian[now].ch[t];
        withdraw(lens);
    }
    bool match(int t) {
        return dian[now].ch[t];
    }
}A;
ll dp[N];
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    while(cin >> s + 1) {
        int n = strlen(s + 1);
        cin >> p >> q;
        A.init(n);
        int l = 2, r = 1;
        A.add(s[1] - 'a'); dp[1] = p;
        for(int i = 2; i <= n; i++) {
            ++r; int tmp = s[i] - 'a';
            dp[i] = dp[i - 1] + p;
            while((!A.match(tmp) || r - l + 1 > i / 2) && l <= r) {
                A.add(s[l++] - 'a');
                A.withdraw(r - l);
            }
            A.trans(tmp, r - l + 1);
            dp[i] = min(dp[i], dp[l - 1] + q);
        }
        cout << dp[n] << '\n';
    }
    return 0;
}
	\end{lstlisting}
	\section{最小表示法}
	\begin{lstlisting}
int getmin(char *s){
    int n=strlen(s);
    int i=0,j=1,k=0,t;
    while(i<n && j<n && k<n){
        t=s[(i+k)%n]-s[(j+k)%n];
        if(!t) k++;
        else{
            if(t>0) i+=k+1;
            else j+=k+1;
            if(i==j) j++;
            k=0;
        }
    }
    return i<j?i:j;
} 
	\end{lstlisting}
	\chapter{数据结构}
	\section{笛卡尔树}
	\begin{lstlisting}
pii b[N];
struct Cartesian_Tree{
    struct node{
        int id, val, fa;
        int son[2];
        node(){}
        node(int id, int val, int fa) : id(id), val(val), fa(fa) {
            son[0] = son[1] = 0;
        }
    }tr[N];
    int rt;
    void init() {
        tr[0] = node(0, 1e9, 0);
    }
    void build(int n, int *a) {
        for(int i = 1; i <= n; i++) tr[i] = (i, a[i], 0);
        for(int i = 1; i <= n; i++) {
            int k = i - 1;
            while(tr[k].val < tr[i].val) k = tr[k].fa;
            tr[i].son[0] = tr[k].son[1];
            tr[k].son[1] = i;
            tr[i].fa = k;
            tr[tr[i].son[0]].fa = i;
        }
        rt = tr[0].son[1];
    }
    int dfs(int u) {
        if(!u) return 0;
        int lsz = dfs(tr[u].son[0]);
        int rsz = dfs(tr[u].son[1]);
        b[tr[u].id].fi = lsz;
        b[tr[u].id].se = rsz;
        return lsz + rsz + 1;
    }
}CT; 
	\end{lstlisting}
	\section{线性基}
	普通线性基就不说了，给出线性基求交集的模板。
	
	求交的话大概就是对于两个基集合$B_1,B_2$,枚举$B_2$中的基，如果与$B_1$线性无关，那么就插在$B_1$里面去；否则就对于当前的基，异或掉$B_1$中之前插进去的$B_2$的基，然后将其插入交集里面就行了。
	
	线段树维护线性基交：
	\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned int ui;
const int N = 50005;
int n, m;
struct node{
    ui r[32], f[32];
    bool ins(ui x) {
        for(int i = 31; i >= 0; i--) {
            if(x >> i) {
                if(!r[i]) {r[i] = x; return 1;}
                else x ^= r[i];
            }
        }
        return 0;
    }
    bool ins2(ui x) {
        ui tmp = x;
        for(int i = 31; i >= 0; i--) {
            if(x >> i) {
                if(!r[i]) {r[i] = x; f[i] = tmp; return 1;}
                else {
                    x ^= r[i]; tmp ^= f[i];
                }
            }
        }
        return 0;
    }
    void clear() {
        for(int i = 0; i <= 31; i++) r[i] = f[i] = 0;
    }
    bool find(ui x) {
        for(int i = 31; i >= 0; i--) {
            if(x >> i) {
                if(!r[i]) return 0;
                x ^= r[i];
            }
        }
        return x == 0;
    }
    int calc(ui x) {
        int ans = 0;
        for(int i = 31; i >= 0; i--) {
            if(x >> i) {
                x ^= r[i];
                ans ^= f[i];
            }
        }
        return ans;
    }
};
node _merge(node u, node v) {
    node tmp, res; res.clear();
    tmp = u;
    for(int i = 31; i >= 0; i--) {
        ui x = v.r[i];
        if(tmp.find(x)) {
            res.ins(x ^ tmp.calc(x));
        } else tmp.ins2(x);
    }
    return res;
}
ui a[N][33];
node b[N << 2];
void build(int o, int l, int r) {
    if(l == r) {
        b[o].clear();
        for(int j = 1; j <= 32; j++) b[o].ins(a[l][j]);
        return ;
    }
    int mid = (l + r) >> 1;
    build(o << 1, l, mid); build(o << 1|1, mid + 1, r);
    b[o] = _merge(b[o << 1], b[o << 1|1]);
}
bool query(int o, int l, int r, int L, int R, ui v) {
    if(L <= l && r <= R) {
        return b[o].find(v);
    }
    int mid = (l + r) >> 1;
    bool ans = 1;
    if(L <= mid) ans &= query(o << 1, l, mid, L, R, v);
    if(R > mid) ans &= query(o << 1|1, mid + 1, r, L, R, v) ;
    return ans;
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        int k; cin >> k;
        for(int j = 1; j <= k; j++) cin >> a[i][j];
    }
    build(1, 1, n);
    for(int i = 1, l, r; i <= m; i++) {
        ui x; cin >> l >> r >> x;
        if(query(1, 1, n, l, r, x)) cout << "YES" << '\n';
        else cout << "NO" << '\n';
    }
    return 0;
}
	\end{lstlisting}
	\section{李超树}
	题意：
	现在需要维护两种操作，一种是插入一条线段，另一种是询问$x=k$时，最上方线段的编号，如有多个线段处于最大值状态，那么就输出编号最小的。
	强制在线。
	
	李超树模板题，注意其标记可持久化。
	\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5, MAX = 50005;
int n;

struct node{
    bool sign; int id;
    double k, b;
    void upd(int _id, double _k, double _b) {
        id = _id, k = _k, b = _b;
    }
}tr[MAX << 3];

void update(int o, int l, int r, int id, double k, double b) {
    if(!tr[o].sign) {
        tr[o].sign = 1;
        tr[o].upd(id, k, b);
        return;
    }
    double l1 = l * tr[o].k + tr[o].b, l2 = l * k + b;
    double r1 = r * tr[o].k + tr[o].b, r2 = r * k + b;
    if(l2 <= l1 && r2 <= r1) return;
    if(l2 > l1 && r2 > r1) {
        tr[o].upd(id, k, b); return;
    }
    int mid = (l + r) >> 1;
    double x = (tr[o].b - b) / (k - tr[o].k);
    if(x <= mid) {
        if(l1 > l2) update(o << 1, l, mid, tr[o].id, tr[o].k, tr[o].b), tr[o].upd(id, k, b);
        else update(o << 1, l, mid, id, k, b);
    } else {
        if(l1 > l2) update(o << 1|1, mid + 1, r, id, k, b);
        else update(o << 1|1, mid + 1, r, tr[o].id, tr[o].k, tr[o].b), tr[o].upd(id, k, b);
    }
}

void update(int o, int l, int r, int L, int R, int id, double k, double b) {
    if(L <= l && r <= R) {
        update(o, l, r, id, k, b); return;
    }
    int mid = (l + r) >> 1;
    if(L <= mid) update(o << 1, l, mid, L, R, id, k, b);
    if(R > mid) update(o << 1|1, mid + 1, r, L, R, id, k, b);
}

void chk(int &res, int o1, int o2, int x) {
    double y1, y2;
    y1 = x * tr[o1].k + tr[o1].b;
    y2 = x * tr[o2].k + tr[o2].b;
    if(y1 > y2 && tr[o1].sign) res = o1;
    else if(y1 < y2 && tr[o2].sign) res = o2;
    else if(y1 == y2){
        if(tr[o1].id < tr[o2].id && tr[o1].sign) res = o1;
        else if(tr[o1].id > tr[o2].id && tr[o2].sign) res = o2;
    }
    return;
}

int query(int o, int l, int r, int p) {
    if(l == r) return o;
    int mid = (l + r) >> 1, res = 0;
    if(p <= mid) chk(res, query(o << 1, l, mid, p), o, p);
    else chk(res, query(o << 1|1, mid + 1, r, p), o, p);
    return res;
}

int main() {
//    freopen("input.in", "r", stdin);
    scanf("%d", &n);
    int lastans = 0, cnt = 0;
    for(int i = 1; i <= n; i++) {
        int op; scanf("%d", &op);
        if(op == 0) {
            int k; scanf("%d", &k);
            int x = (k + lastans - 1) % 39989 + 1;
            int o = query(1, 1, MAX, x);
            lastans = tr[o].id;
            printf("%d\n", lastans);
        } else {
            int x1, x2, y1, y2; ++cnt;
            scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
            x1 = (x1 + lastans - 1) % 39989 + 1;
            y1 = (y1 + lastans - 1) % 1000000000 + 1;
            x2 = (x2 + lastans - 1) % 39989 + 1;
            y2 = (y2 + lastans - 1) % 1000000000 + 1;
            if(x1 > x2) swap(x1, x2), swap(y1, y2);
            double k = 1.0 * (y1 - y2) / (x1 - x2), b = y1 - k * x1;
            update(1, 1, MAX, x1, x2, cnt, k, b);
        }
    }
    return 0;
}
	\end{lstlisting}
	\section{CDQ分治}
	题意：
	现有两种操作，插入和查询，插入操作则插入一个点$(x,y,z)$，查询操作给出两个点$(x1,y1,z1),(x2,y2,z2)$，回答满足$x1≤x≤x2,y1≤y≤y2,z1≤z≤z2$的(x,y,z)的个数为多少。
	
	带修改的四维偏序，四维分别为时间、x、y、z，直接cdq套cdq就行。
	\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 50005;

int T, q;

struct node{
    int x, y, z, op, id, part;
}a[N * 10], b[N * 10], d[N * 10];

int hs[N << 2];

bool isq[N];
int ans[N];

int c[N << 2];
int lowbit(int x) {return x & (-x);}

void update(int x, int v) {
    for(; x < N << 2; x += lowbit(x)) c[x] += v;
}

int query(int x) {
    int ans = 0;
    for(; x; x -= lowbit(x)) ans += c[x];
    return ans;
}

void cdq2(int l, int r) {
    if(l == r) return ;
    int mid = (l + r) >> 1;
    cdq2(l, mid); cdq2(mid + 1, r);
    int t1 = l, t2 = mid + 1;
    for(int i = l; i <= r; i++) {
        if(t2 > r || (t1 <= mid && b[t1].y <= b[t2].y)) {
            if(b[t1].part == 0 && b[t1].op == 0) {
                update(b[t1].z, 1);
            }
            d[i] = b[t1++];
        } else {
            if(b[t2].part && b[t2].op != 0) {
                ans[b[t2].id] += b[t2].op * query(b[t2].z);
            }
            d[i] = b[t2++];
        }
    }
    for(int i = l; i <= mid; i++) {
        if(b[i].part == 0 && b[i].op == 0) update(b[i].z, -1);
    }
    for(int i = l; i <= r; i++) b[i] = d[i];
}

void cdq(int l, int r) {
    if(l == r) return ;
    int mid = (l + r) >> 1;
    cdq(l, mid); cdq(mid + 1, r);
    int t1 = l, t2 = mid + 1;
    for(int i = l; i <= r; i++) {
        if(t2 > r || (t1 <= mid && a[t1].x <= a[t2].x)) {
            b[i] = a[t1++];
            b[i].part = 0;
        } else {
            b[i] = a[t2++];
            b[i].part = 1;
        }
    }
    for(int i = l; i <= r; i++) a[i] = b[i];
    cdq2(l, r);
}

int main() {
//    freopen("input.in", "r", stdin);
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> T;
    while(T--) {
        cin >> q;
        for(int i = 1; i <= q; i++) ans[i] = 0, isq[i] = false;
        int cnt = 0; hs[0] = 0;
        for(int i = 1; i <= q; i++) {
            int op; cin >> op;
            if(op == 1) {
                int x, y, z; cin >> x >> y >> z;
                a[++cnt] = {x, y, z, 0, i, -1};
                hs[++hs[0]] = z;
            } else {
                isq[i] = true;
                int x1, y1, z1, x2, y2, z2;
                cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
                --x1, --y1, --z1;
                a[++cnt] = {x1, y1, z1, -1, i, -1};
                a[++cnt] = {x1, y2, z1, 1, i, -1};
                a[++cnt] = {x2, y2, z1, -1, i, -1};
                a[++cnt] = {x2, y1, z1, 1, i, -1};
                a[++cnt] = {x1, y1, z2, 1, i, -1};
                a[++cnt] = {x1, y2, z2, -1, i, -1};
                a[++cnt] = {x2, y2, z2, 1, i, -1};
                a[++cnt] = {x2, y1, z2, -1, i, -1};
                hs[++hs[0]] = z1, hs[++hs[0]] = z2;
            }
        }
        sort(hs + 1, hs + hs[0] + 1);
        hs[0] = unique(hs + 1, hs + hs[0] + 1) - hs - 1;
        for(int i = 1; i <= cnt; i++) a[i].z = lower_bound(hs + 1, hs + hs[0] + 1, a[i].z) - hs;
        cdq(1, cnt);
        for(int i = 1; i <= q; i++) {
            if(isq[i]) cout << ans[i] << '\n';
        }
    }
    return 0;
}
	\end{lstlisting}
	\section{并查集}
	线段树维护可撤销并查集。
	
	因为可撤销，所以不能路径压缩，注意启发式合并。
	\begin{lstlisting}
#include <bits/stdc++.h>
#define MP make_pair
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int N = 2e5 + 5;
int n, m;
struct node{
    int u, v, l, r;
}a[N];
int b[N], D;
vector <int> c[N << 2];
vector <pair<int, int> > d[100];
ll ans;
void insert(int o, int l, int r, int L, int R, int id) {
    if(L <= l && r <= R) {
        c[o].push_back(id);
        return;
    }
    int mid = (l + r) >> 1;
    if(L <= mid) insert(o << 1, l, mid, L, R, id);
    if(R > mid) insert(o << 1|1, mid + 1, r, L, R, id);
}
int f[N], sz[N];
int find(int x) {
    return f[x] == x ? x : find(f[x]);
}
void merge(int x, int y, int dep) {
    int fx = find(x), fy = find(y);
    if(fx == fy) return;
    if(sz[fx] > sz[fy]) swap(fx, fy);
    int tmp = 0;
    f[fx] = fy;
    if(sz[fx] == sz[fy]) tmp++;
    sz[fy] += tmp;
    d[dep].push_back(MP(fx, tmp));
}
void del(int dep) {
    for(auto it : d[dep]) {
        sz[f[it.first]] -= it.second;
        f[it.first] = it.first;
    }
    d[dep].clear();
}
void dfs(int o, int l, int r, int dep) {
    for(auto it : c[o]) {
        merge(a[it].u, a[it].v, dep);
    }
    if(find(1) == find(n)) {
        ans += b[r + 1] - b[l];
    } else if(l < r) {
        int mid = (l + r) >> 1;
        dfs(o << 1, l, mid, dep + 1);
        dfs(o << 1|1, mid + 1, r, dep + 1);
    }
    del(dep);
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        cin >> a[i].u >> a[i].v >> a[i].l >> a[i].r;
        b[++D] = a[i].l, b[++D] = a[i].r + 1;
    }
    sort(b + 1, b + D + 1);
    D = unique(b + 1, b + D + 1) - b - 1;
    for(int i = 1; i <= m; i++) {
        a[i].l = lower_bound(b + 1, b + D + 1, a[i].l) - b;
        a[i].r = lower_bound(b + 1, b + D + 1, a[i].r + 1) - b - 1;
        insert(1, 1, D, a[i].l, a[i].r, i);
    }
    for(int i = 1; i <= n; i++) f[i] = i, sz[i] = 1;
    dfs(1, 1, D, 1);
    cout << ans;
    return 0;
}
	\end{lstlisting}
	
	\section{kd-tree}
	一种多维二叉搜索树，每一层有不同的排序规则。
	
	寻找最近点、最远点之类的复杂度为$O(logn)$~$O(n)$，而矩阵查询、修改之类的复杂度一般为$O(n\sqrt{n})$。
	
	矩阵查询，单点修改，复杂度都为$O(\sqrt{n})$
	\begin{lstlisting}
int D;
struct Point {
    int d[2];
    Point(int x = 0, int y = 0) {
        d[0] = x, d[1] = y; 
    }  
    int& operator[] (int x) {return d[x];}
}p[N];
struct Node{
    int mn[2], mx[2];
    int l, r, col;
    bool lz;
    Point t;
}tr[N];
bool operator < (const Point &A, const Point &B) {
    return A.d[D] < B.d[D];   
}
bool operator == (const Point &A, const Point &B) {
    return A.d[0] == B.d[0] && A.d[1] == B.d[1];   
}
int rt;
struct kdtree {
    void push_up(int o) {
        int ls = tr[o].l, rs = tr[o].r;
        for(int i = 0; i < 2; i++) {
            tr[o].mn[i] = tr[o].mx[i] = tr[o].t[i];
            if(ls) {
                tr[o].mn[i] = min(tr[o].mn[i], tr[ls].mn[i]);
                tr[o].mx[i] = max(tr[o].mx[i], tr[ls].mx[i]);   
            }
            if(rs) {
                tr[o].mn[i] = min(tr[o].mn[i], tr[rs].mn[i]);
                tr[o].mx[i] = max(tr[o].mx[i], tr[rs].mx[i]);
            }
        }
    }
    void push_down(int o) {
        if(tr[o].lz) {
            if(tr[o].l) {
                tr[tr[o].l].lz = true;
                tr[tr[o].l].col = tr[o].col;
            }
            if(tr[o].r) {
                tr[tr[o].r].lz = true;
                tr[tr[o].r].col = tr[o].col;
            }
            tr[o].lz = false;
        }   
    }
    int build(int l, int r, int now) {
        D = now;
        int mid = (l + r) >> 1;
        nth_element(p + l, p + mid, p + r + 1);
        tr[mid].t = p[mid];
        tr[mid].lz = false;
        tr[mid].col = 1; 
        if(l < mid) tr[mid].l = build(l, mid - 1, now ^ 1);
        else tr[mid].l = 0;
        if(r > mid) tr[mid].r = build(mid + 1, r, now ^ 1);
        else tr[mid].r = 0;
        push_up(mid);
        return mid;
    }
    int query(int o, Point T, int now) {
        if(o == 0) return 0;
        if(tr[o].t == T) return tr[o].col;
        push_down(o);
        D = now;
        if(T.d[D] < tr[o].t.d[D]) return query(tr[o].l, T, now ^ 1);
        else return query(tr[o].r, T, now ^ 1);
    }
    void update(int o, int l, int r, int d, int u, int c) {
        if(tr[o].mn[0] >= l && tr[o].mx[0] <= r && tr[o].mn[1] >= d && tr[o].mx[1] <= u) {
            tr[o].col = c; tr[o].lz = true;
            return;   
        }
        if(tr[o].mn[0] > r || tr[o].mx[0] < l || tr[o].mn[1] > u || tr[o].mx[1] < d) return;
        push_down(o);
        if(tr[o].t[0] >= l && tr[o].t[0] <= r && tr[o].t[1] >= d && tr[o].t[1] <= u) {
            tr[o].col = c;   
        }
        if(tr[o].l) update(tr[o].l, l, r, d, u, c);
        if(tr[o].r) update(tr[o].r, l, r, d, u, c);
    }
}kd;
	\end{lstlisting}
	矩阵查询，支持修改和树的重构（设立一个阀值），区间查询，动态开点。
	\begin{lstlisting}
int n;
int D;
struct Point {
    int d[2], val;  
}tmp[N], T;
struct Node {
    int mn[2], mx[2];
    int l, r, sumv, sz;
    Point t;
}tr[N];
bool operator < (const Point &A, const Point &B) {
    return A.d[D] < B.d[D];   
}
int rt;
int rub[N], top, tot;
struct kdtree {
    const double E = 0.75;
    int ans;
    int new_node() {
        if(top) return rub[top--];
        return ++tot;
    }
    void push_up(int o) {
        int ls = tr[o].l, rs = tr[o].r;
        for(int i = 0; i < 2; i++) {
            tr[o].mn[i] = tr[o].mx[i] = tr[o].t.d[i];
            if(ls) {
                tr[o].mn[i] = min(tr[o].mn[i], tr[ls].mn[i]);
                tr[o].mx[i] = max(tr[o].mx[i], tr[ls].mx[i]);   
            }
            if(rs) {
                tr[o].mn[i] = min(tr[o].mn[i], tr[rs].mn[i]);
                tr[o].mx[i] = max(tr[o].mx[i], tr[rs].mx[i]);
            }
        }
        tr[o].sumv = tr[ls].sumv + tr[rs].sumv + tr[o].t.val;
        tr[o].sz = 1 + tr[ls].sz + tr[rs].sz;
    }
    void pia(int o, int num) {
        int ls = tr[o].l, rs = tr[o].r;
        if(ls) pia(ls, num);
        tmp[tr[ls].sz + num + 1] = Point{tr[o].t.d[0], tr[o].t.d[1], tr[o].t.val}; 
        rub[++top] = o;
        if(rs) pia(rs, tr[ls].sz + num + 1);
    }
    int rebuild(int l, int r, int now) {
        if(l > r) return 0;
        D = now;
        int mid = (l + r) >> 1;
        nth_element(tmp + l, tmp + mid, tmp + r + 1);
        int node = new_node();
        tr[node].t = tmp[mid];
        tr[node].l = rebuild(l, mid - 1, now ^ 1);
        tr[node].r = rebuild(mid + 1, r, now ^ 1);
        push_up(node);
        return node;
    }
    void chk(int &o, int now) {
        if(tr[o].sz * E <= tr[tr[o].l].sz || tr[o].sz * E <= tr[tr[o].r].sz) {
            pia(o, 0);
            o = rebuild(1, tr[o].sz, now);
        }   
    }
    void insert(int &o, int now) {
        if(!o) {
            tr[o = new_node()].t = T;
            tr[o].l = tr[o].r = 0;
            push_up(o);
            return;   
        }
        D = now;
        if(tr[o].t.d[D] < T.d[D]) insert(tr[o].r, now ^ 1);
        else insert(tr[o].l, now ^ 1);
        push_up(o);
        chk(o, now);
    }
    bool in(int x, int y, int x1, int y1, int x2, int y2) {
        return x >= x1 && x <= x2 && y >= y1 && y <= y2;   
    }
    void query(int o, int x1, int y1, int x2, int y2) {
        if(o == 0) return;
        if(tr[o].mn[0] >= x1 && tr[o].mx[0] <= x2 && tr[o].mn[1] >= y1 && tr[o].mx[1] <= y2) {
            ans += tr[o].sumv;
            return;   
        }
        if(tr[o].mn[0] > x2 || tr[o].mx[0] < x1 || tr[o].mn[1] > y2 || tr[o].mx[1] < y1) return;
        if(in(tr[o].t.d[0], tr[o].t.d[1], x1, y1, x2, y2)) ans += tr[o].t.val;
        query(tr[o].l, x1, y1, x2, y2);
        query(tr[o].r, x1, y1, x2, y2);
    }
}kd; 
	\end{lstlisting}
	\chapter{其它}
	\section{莫队算法}
	对区间问题离线处理，按照一定规则排序，之后指针暴力移动就行。
	核心代码：
	\begin{lstlisting}
for(; r < q[i].r; r++) add(r + 1, 1);
for(; r > q[i].r; r--) add(r, -1);
for(; l < q[i].l; l++) add(l, -1);
for(; l > q[i].l; l--) add(l - 1, 1);
for(; t < q[i].k; t++) Update(upd[t + 1]);
for(; t > q[i].k; t--) Update(upd[t]);
	\end{lstlisting}
	\section{点分治}
	优雅的暴力，对于一颗无根树每次以树的重心为根容斥计算答案，本质相当于枚举每一个结点作为路径上面的必经点然后来考虑。
	复杂度一般为$O(nlogn)$。
	
	寻找两点之间路径为$3$的倍数的代码：
	\begin{lstlisting}
#include <bits/stdc++.h>
#define MP make_pair
#define fi first
#define se second
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int N = 20005;
int n;
vector <pii> g[N];
int sz[N], mx[N], tsz;
int d[N];
int rt, ans, cnt;
bool vis[N];
void getrt(int u, int fa) {
    sz[u] = 1; mx[u] = 0;
    for(auto it : g[u]) {
        int v = it.fi;
        if(v == fa || vis[v]) continue;
        getrt(v, u);
        sz[u] += sz[v];
        if(sz[v] > mx[u]) mx[u] = sz[v];
    }
    mx[u] = max(mx[u], tsz - sz[u]);
    if(mx[u] < mx[rt]) rt = u;
}
void dfs2(int u, int D, int fa) {
    d[++cnt] = D;
    for(auto it : g[u]) {
        int v = it.fi, w = it.se;
        if(vis[v] || v == fa) continue;
        dfs2(v, D + w, u);
    }
}
int calc() {
    for(int i = 1; i <= cnt; i++) d[i] %= 3;
    int tmp[3] = {0, 0, 0};
    for(int i = 1; i <= cnt; i++) ++tmp[d[i]];
    int ans = tmp[0] * (tmp[0] - 1) + 2 * (tmp[1] * tmp[2]);
    return ans;
}
void dfs(int u) {
    vis[u] = 1;
    cnt = 0; dfs2(u, 0, 0);
    int tmp = calc();
    ans += tmp;
    for(auto it : g[u]) {
        int v = it.fi, w = it.se;
        if(vis[v]) continue;
        cnt = 0, dfs2(v, w, 0);
        ans -= calc();
        tsz = sz[v], rt = 0, getrt(v, u);
        dfs(rt);
    }
}
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n;
    for(int i = 1; i < n; i++) {
        int u, v, w; cin >> u >> v >> w;
        g[u].push_back(MP(v, w)); g[v].push_back(MP(u, w));
    }
    tsz = n, mx[0] = INF, getrt(1, 0);
    dfs(rt);
    ans += n;
    int tot = n * n;
    int g = gcd(tot, ans);
    ans /= g, tot /= g;
    cout << ans << '/' << tot;
    return 0;
}
	\end{lstlisting}
	\section{随机数}
	\begin{lstlisting}
mt19937 rnd(time(NULL));
rnd()%n; 
	\end{lstlisting}
	\section{最大子矩阵}
	\begin{lstlisting}
int a[N][N];
int n, m;
#define mp make_pair
#define se second
#define fi first
namespace max_matrix{
    int vis[N], f[N], sz[N];
    int t[N][N];
    int mx = 0, mx2 = 0;
    pair<int, int> h[N];
    int find(int x) {
        return f[x] == x ? x : f[x] = find(f[x]) ;
    }
    void Union(int x, int y) {
        int fx = find(x), fy = find(y);
        f[fx] = fy;
        sz[fy] += sz[fx];
    }
    void solve(int a, int b) {
        int area = a * b;
        if(area > mx) mx2 = mx, mx = area;
        else if(area > mx2) mx2 = area;
    }
    int work(int n, int m, int a[][N]) {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++) {
                t[i][j] = (a[i][j] == 1) ? t[i - 1][j] + 1 : 0;
            }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                f[j] = j, vis[j] = 0, h[j] = mp(t[i][j], j), sz[j] = 1;
            }
            sort(h + 1, h + m + 1);
            for(int j = m; j >= 1; j--) {
                int k = h[j].se; vis[k] = 1;
                if(vis[k - 1]) Union(k - 1, k);
                if(vis[k + 1]) Union(k + 1, k);
                int len = sz[find(k)];
                solve(len, h[j].fi);
                solve(len - 1, h[j].fi);
                solve(len, h[j].fi - 1);
            }
        }
        return mx2;
    }
}; 
	\end{lstlisting}
	\section{快速读入/输出}
	\begin{lstlisting}
struct Istream {
	template <class T>
	Istream &operator >>(T &x) {
		static char ch;static bool neg;
		for(ch=neg=0;ch<'0' || '9'<ch;neg|=ch=='-',ch=getchar());
		for(x=0;'0'<=ch && ch<='9';(x*=10)+=ch-'0',ch=getchar());
		x=neg?-x:x;
		return *this;
	}
}fin;

struct Ostream {
	template <class T>
	Ostream &operator <<(T x) {
		x<0 && (putchar('-'),x=-x);
		static char stack[233];static int top;
		for(top=0;x;stack[++top]=x%10+'0',x/=10);
		for(top==0 && (stack[top=1]='0');top;putchar(stack[top--]));
		return *this;
	}

	Ostream &operator <<(char ch) {
		putchar(ch);
		return *this;
	}
}fout; 
	\end{lstlisting}
	\section{二进制函数}
	\begin{lstlisting}
__builtin_popcount(); //1的个数
__builtin_parity(); //1个数的奇偶
__builtin_ffs(); //最后一个1的位置 
	\end{lstlisting}
	
\end{document}
\label{LastPage}
